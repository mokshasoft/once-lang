{-|
Module      : Once.Backend.X86
Description : x86-64 assembly code generator for Once
Copyright   : (c) 2024
License     : GPL-2.0

Generate x86-64 assembly code from Once IR.

This backend produces assembly that can be assembled with:
  - NASM: nasm -f elf64 output.asm -o output.o
  - GAS:  as output.s -o output.o

The generated code follows the System V AMD64 ABI:
  - Arguments: rdi, rsi, rdx, rcx, r8, r9
  - Return: rax
  - Callee-saved: rbx, rbp, r12-r15
  - Caller-saved: rax, rcx, rdx, rsi, rdi, r8-r11

For Once closures:
  - r12: environment pointer (callee-saved)
  - Closure layout: [env_ptr (8 bytes), code_ptr (8 bytes)]

For products (pairs):
  - Memory layout: [fst (8 bytes), snd (8 bytes)]

For sums (tagged unions):
  - Memory layout: [tag (8 bytes), value (8 bytes)]
  - tag = 0 for inl, tag = 1 for inr
-}
module Once.Backend.X86
  ( generateX86
  , generateAsm
  , X86Module (..)
  , AsmFormat (..)
  ) where

import Data.Text (Text)
import qualified Data.Text as T

import Once.IR (IR (..))
import Once.Type (Type (..), Name)

-- | Assembly format
data AsmFormat
  = NASM    -- ^ NASM syntax (Intel)
  | GAS     -- ^ GNU Assembler syntax (AT&T)
  deriving (Eq, Show)

-- | Generated x86-64 module
data X86Module = X86Module
  { asmSource :: Text    -- ^ Assembly source code
  , asmFormat :: AsmFormat
  } deriving (Eq, Show)

-- | Generate x86-64 assembly for a named function
generateX86 :: AsmFormat -> Name -> Type -> IR -> X86Module
generateX86 fmt name ty ir = X86Module
  { asmSource = generateAsm fmt name ty ir
  , asmFormat = fmt
  }

-- | Generate assembly source code
generateAsm :: AsmFormat -> Name -> Type -> IR -> Text
generateAsm NASM name ty ir = generateNASM name ty ir
generateAsm GAS name ty ir = generateGAS name ty ir

------------------------------------------------------------------------
-- NASM (Intel syntax) generation
------------------------------------------------------------------------

-- | Generate NASM assembly
generateNASM :: Name -> Type -> IR -> Text
generateNASM name ty ir = T.unlines $
  [ "; Generated by Once compiler"
  , "; NASM syntax (Intel)"
  , ""
  , "section .data"
  , ""
  , "section .bss"
  , ""
  , "section .text"
  , "global once_" <> name
  , ""
  , "once_" <> name <> ":"
  ] ++
  nasmPrologue ++
  [ "    ; Function body" ] ++
  generateIRNasm ir "rdi" "rax" 0 ++
  nasmEpilogue

-- | NASM function prologue
nasmPrologue :: [Text]
nasmPrologue =
  [ "    ; Prologue"
  , "    push rbp"
  , "    mov rbp, rsp"
  , "    push r12          ; Save callee-saved registers"
  , "    push r13"
  , "    push r14"
  , "    push r15"
  , ""
  ]

-- | NASM function epilogue
nasmEpilogue :: [Text]
nasmEpilogue =
  [ ""
  , "    ; Epilogue"
  , "    pop r15"
  , "    pop r14"
  , "    pop r13"
  , "    pop r12"
  , "    pop rbp"
  , "    ret"
  ]

-- | Generate NASM instructions for IR
-- inputReg: register containing input value
-- outputReg: register for output value
-- labelCounter: for generating unique labels
generateIRNasm :: IR -> Text -> Text -> Int -> [Text]
generateIRNasm ir inputReg outputReg labelCtr = case ir of
  Id _ ->
    -- id: just move input to output
    if inputReg == outputReg
      then ["    ; id (no-op)"]
      else ["    mov " <> outputReg <> ", " <> inputReg]

  Fst _ _ ->
    -- fst: load first field (offset 0) from pair pointer
    [ "    ; fst"
    , "    mov " <> outputReg <> ", [" <> inputReg <> "]"
    ]

  Snd _ _ ->
    -- snd: load second field (offset 8) from pair pointer
    [ "    ; snd"
    , "    mov " <> outputReg <> ", [" <> inputReg <> "+8]"
    ]

  Pair f g ->
    -- pair f g: allocate pair, compute f and g, store results
    -- Simplified: assumes stack allocation
    [ "    ; pair"
    , "    sub rsp, 16              ; Allocate pair on stack"
    , "    mov r14, rsp             ; r14 = pair address"
    ] ++
    generateIRNasm f inputReg "r15" labelCtr ++
    [ "    mov [r14], r15           ; Store fst" ] ++
    generateIRNasm g inputReg "r15" (labelCtr + 1) ++
    [ "    mov [r14+8], r15         ; Store snd"
    , "    mov " <> outputReg <> ", r14"
    ]

  Compose g f ->
    -- compose g f: first apply f, then g
    [ "    ; compose" ] ++
    generateIRNasm f inputReg "r15" labelCtr ++
    generateIRNasm g "r15" outputReg (labelCtr + 1)

  Terminal _ ->
    -- terminal: return unit (NULL/0)
    [ "    ; terminal (unit)"
    , "    xor " <> outputReg <> ", " <> outputReg
    ]

  Inl _ _ ->
    -- inl: create tagged union with tag = 0
    [ "    ; inl"
    , "    sub rsp, 16              ; Allocate sum on stack"
    , "    mov qword [rsp], 0       ; tag = 0"
    , "    mov [rsp+8], " <> inputReg <> "  ; value"
    , "    mov " <> outputReg <> ", rsp"
    ]

  Inr _ _ ->
    -- inr: create tagged union with tag = 1
    [ "    ; inr"
    , "    sub rsp, 16              ; Allocate sum on stack"
    , "    mov qword [rsp], 1       ; tag = 1"
    , "    mov [rsp+8], " <> inputReg <> "  ; value"
    , "    mov " <> outputReg <> ", rsp"
    ]

  Case l r ->
    -- case l r: branch on tag
    let lbl = tshow labelCtr
        lblElse = ".case_else_" <> lbl
        lblEnd = ".case_end_" <> lbl
    in [ "    ; case"
       , "    mov r15, [" <> inputReg <> "]     ; Load tag"
       , "    cmp r15, 0"
       , "    jne " <> lblElse
       , "    ; Left branch (tag = 0)"
       , "    mov r15, [" <> inputReg <> "+8]   ; Load value"
       ] ++
       generateIRNasm l "r15" outputReg (labelCtr + 1) ++
       [ "    jmp " <> lblEnd
       , lblElse <> ":"
       , "    ; Right branch (tag = 1)"
       , "    mov r15, [" <> inputReg <> "+8]   ; Load value"
       ] ++
       generateIRNasm r "r15" outputReg (labelCtr + 2) ++
       [ lblEnd <> ":"
       ]

  Initial _ ->
    -- initial: unreachable (Void has no inhabitants)
    [ "    ; initial (unreachable)"
    , "    ud2"
    ]

  Curry _ ->
    -- curry: create closure (simplified - not fully implemented)
    [ "    ; curry (closure creation)"
    , "    ; TODO: Full closure implementation"
    , "    xor " <> outputReg <> ", " <> outputReg
    ]

  Apply _ _ ->
    -- apply: call closure (simplified - not fully implemented)
    [ "    ; apply (closure call)"
    , "    ; TODO: Full closure implementation"
    , "    xor " <> outputReg <> ", " <> outputReg
    ]

  Var n ->
    -- Function call
    [ "    ; call " <> n
    , "    mov rdi, " <> inputReg
    , "    call once_" <> n
    , "    mov " <> outputReg <> ", rax"
    ]

  LocalVar n ->
    -- Local variable reference
    [ "    ; local var " <> n
    , "    mov " <> outputReg <> ", " <> n
    ]

  FunRef n ->
    -- Function reference (address)
    [ "    ; function ref " <> n
    , "    lea " <> outputReg <> ", [once_" <> n <> "]"
    ]

  Prim n _ _ ->
    -- Primitive call
    [ "    ; primitive " <> n
    , "    mov rdi, " <> inputReg
    , "    call once_" <> n
    , "    mov " <> outputReg <> ", rax"
    ]

  StringLit s ->
    -- String literal (would need data section allocation)
    [ "    ; string literal (TODO: data section)"
    , "    xor " <> outputReg <> ", " <> outputReg
    ]

  Fold _ ->
    -- fold: identity at runtime
    [ "    ; fold (identity)"
    , "    mov " <> outputReg <> ", " <> inputReg
    ]

  Unfold _ ->
    -- unfold: identity at runtime
    [ "    ; unfold (identity)"
    , "    mov " <> outputReg <> ", " <> inputReg
    ]

  Let x e1 e2 ->
    -- let binding
    [ "    ; let " <> x ] ++
    generateIRNasm e1 inputReg x (labelCtr + 1) ++
    generateIRNasm e2 x outputReg (labelCtr + 2)

------------------------------------------------------------------------
-- GAS (AT&T syntax) generation
------------------------------------------------------------------------

-- | Generate GAS assembly
generateGAS :: Name -> Type -> IR -> Text
generateGAS name ty ir = T.unlines $
  [ "# Generated by Once compiler"
  , "# GAS syntax (AT&T)"
  , ""
  , ".data"
  , ""
  , ".bss"
  , ""
  , ".text"
  , ".globl once_" <> name
  , ".type once_" <> name <> ", @function"
  , ""
  , "once_" <> name <> ":"
  ] ++
  gasPrologue ++
  [ "    # Function body" ] ++
  generateIRGas ir "%rdi" "%rax" 0 ++
  gasEpilogue

-- | GAS function prologue
gasPrologue :: [Text]
gasPrologue =
  [ "    # Prologue"
  , "    pushq %rbp"
  , "    movq %rsp, %rbp"
  , "    pushq %r12"
  , "    pushq %r13"
  , "    pushq %r14"
  , "    pushq %r15"
  , ""
  ]

-- | GAS function epilogue
gasEpilogue :: [Text]
gasEpilogue =
  [ ""
  , "    # Epilogue"
  , "    popq %r15"
  , "    popq %r14"
  , "    popq %r13"
  , "    popq %r12"
  , "    popq %rbp"
  , "    ret"
  ]

-- | Generate GAS instructions for IR
generateIRGas :: IR -> Text -> Text -> Int -> [Text]
generateIRGas ir inputReg outputReg labelCtr = case ir of
  Id _ ->
    if inputReg == outputReg
      then ["    # id (no-op)"]
      else ["    movq " <> inputReg <> ", " <> outputReg]

  Fst _ _ ->
    [ "    # fst"
    , "    movq (" <> inputReg <> "), " <> outputReg
    ]

  Snd _ _ ->
    [ "    # snd"
    , "    movq 8(" <> inputReg <> "), " <> outputReg
    ]

  Pair f g ->
    [ "    # pair"
    , "    subq $16, %rsp"
    , "    movq %rsp, %r14"
    ] ++
    generateIRGas f inputReg "%r15" labelCtr ++
    [ "    movq %r15, (%r14)" ] ++
    generateIRGas g inputReg "%r15" (labelCtr + 1) ++
    [ "    movq %r15, 8(%r14)"
    , "    movq %r14, " <> outputReg
    ]

  Compose g f ->
    [ "    # compose" ] ++
    generateIRGas f inputReg "%r15" labelCtr ++
    generateIRGas g "%r15" outputReg (labelCtr + 1)

  Terminal _ ->
    [ "    # terminal"
    , "    xorq " <> outputReg <> ", " <> outputReg
    ]

  Inl _ _ ->
    [ "    # inl"
    , "    subq $16, %rsp"
    , "    movq $0, (%rsp)"
    , "    movq " <> inputReg <> ", 8(%rsp)"
    , "    movq %rsp, " <> outputReg
    ]

  Inr _ _ ->
    [ "    # inr"
    , "    subq $16, %rsp"
    , "    movq $1, (%rsp)"
    , "    movq " <> inputReg <> ", 8(%rsp)"
    , "    movq %rsp, " <> outputReg
    ]

  Case l r ->
    let lbl = tshow labelCtr
        lblElse = ".case_else_" <> lbl
        lblEnd = ".case_end_" <> lbl
    in [ "    # case"
       , "    movq (" <> inputReg <> "), %r15"
       , "    cmpq $0, %r15"
       , "    jne " <> lblElse
       , "    # Left branch"
       , "    movq 8(" <> inputReg <> "), %r15"
       ] ++
       generateIRGas l "%r15" outputReg (labelCtr + 1) ++
       [ "    jmp " <> lblEnd
       , lblElse <> ":"
       , "    # Right branch"
       , "    movq 8(" <> inputReg <> "), %r15"
       ] ++
       generateIRGas r "%r15" outputReg (labelCtr + 2) ++
       [ lblEnd <> ":"
       ]

  Initial _ ->
    [ "    # initial (unreachable)"
    , "    ud2"
    ]

  Curry _ ->
    [ "    # curry (TODO)"
    , "    xorq " <> outputReg <> ", " <> outputReg
    ]

  Apply _ _ ->
    [ "    # apply (TODO)"
    , "    xorq " <> outputReg <> ", " <> outputReg
    ]

  Var n ->
    [ "    # call " <> n
    , "    movq " <> inputReg <> ", %rdi"
    , "    call once_" <> n
    , "    movq %rax, " <> outputReg
    ]

  LocalVar n ->
    [ "    # local var " <> n
    , "    movq " <> n <> ", " <> outputReg
    ]

  FunRef n ->
    [ "    # function ref " <> n
    , "    leaq once_" <> n <> "(%rip), " <> outputReg
    ]

  Prim n _ _ ->
    [ "    # primitive " <> n
    , "    movq " <> inputReg <> ", %rdi"
    , "    call once_" <> n
    , "    movq %rax, " <> outputReg
    ]

  StringLit _ ->
    [ "    # string literal (TODO)"
    , "    xorq " <> outputReg <> ", " <> outputReg
    ]

  Fold _ ->
    [ "    # fold"
    , "    movq " <> inputReg <> ", " <> outputReg
    ]

  Unfold _ ->
    [ "    # unfold"
    , "    movq " <> inputReg <> ", " <> outputReg
    ]

  Let x e1 e2 ->
    let xReg = "%" <> x  -- Simplified: use as pseudo-register
    in [ "    # let " <> x ] ++
       generateIRGas e1 inputReg xReg (labelCtr + 1) ++
       generateIRGas e2 xReg outputReg (labelCtr + 2)

------------------------------------------------------------------------
-- Utilities
------------------------------------------------------------------------

-- | Show for Text
tshow :: Show a => a -> Text
tshow = T.pack . show
